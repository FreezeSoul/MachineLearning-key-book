# 第2章：可学性

*Edit: 王茂霖，李一飞，Hao ZHAN，赵志民*

------
## 2.0 本章前言

本章的内容围绕学习理论中的可学性理论展开，主要讨论「事件否能够通过机器学习来解决」这一问题。通过学习理论事先辨别某个问题是否能够被学习，将节省大量的时间与资源。

什么是可行性？
在书中的概念说：对于一个任务，通常我们先要考虑它“是不是可学的（learnable）”.
我们来进一步深入讨论，首先，我们来重新思考一下这个名称“可学性”，我们在设计一个算法之前，我们是不是会首先想这样一些问题，比如说，这个问题是不是能被解决的（从模型的角度说就这个问题是不是可学习的），以及哪些内容是容易学习的（比如两个凸集是好分的），哪些内容是难学习的（比如两个非凸集之间可能是难分的），如果在可学习的情况下，只是需要多少的样本才能保证模型的误差在一定范围内（样本量的问题），有没有一般话的通用的学习模型？

在本章中，我们将通过介绍 "概率近似正确的"（PAC）学习框架，开始正式讨论这些问题。PAC 框架有助于根据实现近似解所需的样本点数量、样本复杂度以及学习算法的时间/空间复杂度（取决于概念的计算表示成本）来定义可学习的概念。

我们首先会描述 PAC 框架并对其进行了说明，然后针对所用假设集包含要学习的概念的一致情况和相反的不一致情况，介绍了当所用假设集有限时该框架内的一些一般学习保证。

---
## 2.1 基本概念

### 2.1.1 基础概念解释

在具体的介绍 PAC 模型之前，首先给出所需的几个定义和符号，这些定义和符号也将贯穿本书的大部分内容:

> $X$：表示所有可能的例子或实例的集合。$X$有时也被称为输入空间。
$Y$：表示所有可能的标签或目标值的集合。$X$有时也被称为输出空间。

*注明：在本介绍性章节中，我们将仅限于把 $Y$ 简化为两个标签的情况，即 $Y = \{0, 1\}$ (或者 $Y = \{-1, 1\}$，两者并无区别，都只是符号上的代替，或者说 $Y = \{皮卡丘, 海绵宝宝\}$，也是可以的)，这相当于所谓的二元分类问题。虽然做了这样的简化假设，这样的先验假设并不影响后续很多推论的路径以及思路，只是多分类的问题相当于二分类的扩展，从证明和论证方面更为复杂，所以这样的假设是不失一般性的，后面的相关章节将把这些结果扩展到更一般的情况。*

*注明：由于PAC可学性等很多机器学习理论基础是建立在统计理论基础之上的，所以本书的绝大部分知识点，都是从统计概率的角度出发的。*

**从数学的角度** 来考虑机器学习中概念：
从数学的角度来说，机器/深度学习可以定义为学习一个映射函数，我们给出定义如下：

> **概念**(concept) $c : X \rightarrow Y$ 是一个从 $X$ 到 $Y$ 的映射。由于 $Y = \{0, 1\}$，我们也可以将 $c$ 视为从$X$中得到为其取值为 $1$ 部分的 $X$ 子集。

*解释: 想象一下，如果我们能得到 $X$中关于其中取值为 $1$ 部分的子集，那么我们通过加一个指示函数，自然就构造出了 $c$，所以从子集角度和从映射的角度是等价的，但从子集角度有一个好处，就是我们将机器学习定位为了集合的划分（或者说样本空间的划分），这将更好的理解机器学习的概念，
举一个简单例子来说，我们可以将$X$定义为一个有限集合：e.g. $\{-1,0,1,2,3\}$, 然后 $c$ 等价于从其中找一个子集：e.g. $\{-1,0,3\}$; 也可以将$X$定义为一个无限集合的子集：e.g. 整个一维实数空间$R$/一个有限区间,e.g. $[-10,10]$, 然后 $c$ 等价于从其中找一个子集:e.g. $[-2,-1]\cup[3,4]$;*

因此，在下文中，我们将学习的概念等同于从 $X$ 到 $\{0, 1\}$ 的映射，或 $X$ 的子集。例如，子集可以是三角形内部的点集或这些点的指示函数。在这种情况下，我们会简短地说要学习的概念是一个三角形。概念类是我们希望学习的概念的集合，用 $\mathcal{C}$ 表示。例如，它可以是平面中所有三角形的集合。

*解释：这里对于三角形的理解是重要的（如果不理解也没关系，因为后面会多次提及），三角形只是一个概念，相当于一个$X$的子集，我们在前文中刚刚提到，从数学角度来说 $c$ 可以视为从$X$中得到为其取值为 $1$ 部分的 $X$ 子集，比如二维平面$R^2$中的一个三角形区域就可以视为其子集，所以三角形可以视为一个映射$c$。*

> **假设空间**（hypothesis space）$\mathcal{H}$：其
>

在机器学习中，假设空间（Hypothesis Space）是指所有可能的模型或假设的集合，这些模型或假设能够对给定的数据进行映射并做出预测。换句话说，假设空间包含了所有可能的函数或映射，它们都能够根据输入数据产生输出结果，如分类、回归或其他预测任务。假设空间的概念对于理解学习算法的能力和限制至关重要。

一个假设空间的大小和复杂性决定了算法能够学习到的解决方案的类型。如果假设空间太小或太简单，它可能无法捕捉到数据中的复杂模式，导致欠拟合（Underfitting）。相反，如果假设空间过大或太复杂，它可能包含过于复杂的模型，这些模型可能会过度拟合（Overfitting）训练数据，从而在新的、未见过的数据上表现不佳，这里用到了我们常说的 **「偏倚方差理论」**。

例如，在一个简单的线性分类器中，假设空间可能包括所有可能的线性边界，每个线性边界都是一个假设。在更复杂的模型中，如神经网络，假设空间可能包括所有可能的网络结构和权重配置，这些构成了网络的能力来学习数据的非线性和复杂模式。
选择合适的假设空间是机器学习中的一个关键步骤，因为它直接影响到学习算法的性能和泛化能力。通常，假设空间的选择需要根据问题的性质、数据的特点以及所需的性能来决定。

需要注意的是，这种理解适用于传统的机器学习，但在深度学习领域，我们观察到的现象更加复杂。
例如，最新的研究中观察到的双下降现象（参考文献：[Deep Double Descent: Where Bigger Models and More Data Hurt](https://arxiv.org/abs/1912.02292)） 表明，对于深层神经网络的双下降机制，我们仍然需要深入理解这样的一个开放性问题。

![double_descent](imgs/double_descent.jpg)



---
### 2.1.2 基础假设

我们首先假设【实例/样本】是独立且同分的，且其符合某种固定但未知的分布$\mathcal{D}$。

学习者会考虑一组固定的可能概念类 $\mathcal{H}$（称为假设集），这组概念不一定与目标的概念类 $\mathcal{C}$ 一致。学习者会收到根据 从$\mathcal{D}$中按照独立同分布抽取的样本集 $X = (x_1, . . , x_m)$ 以及标签集 $Y=(c(x_1), . , c(x_m)）$，这些标签基于要学习的特定目标概念 $c \in \mathcal{C}$。


---
### 2.1.3 基本定义

通过以上的步骤，我们来看看现在我们有了哪些工具基础：现在我们有了样本的分布定义$\mathcal{D}$(但样本分布可能是未知的)，不过幸好我们还有了样本集$D$（这个是可以通过采样观测得到的，同时也可以得到对应的样本标签$Y$，虽然映射关系$c$未知），有了特定的目标概念$c$（期望学习到的东西），也有了可能的概念类$\mathcal{H}$（模型能学习到的所有可能性,比如二维平面的线性函数类），我们发现我们定义可学习还缺了一点工具，其用来衡量学习到的概念$h$同目标概念$c$的差异性度量方式，用来度量两个映射间的距离方式有很多种，但这里我们不过多扩散，从统计学的角度出发给出对应的误差度量，我们称为泛化误差。

假设 $h \in \mathcal{H}$ 的泛化误差(也称为 $h$ 的风险或真实误差（或简称误差）)，用 $R(h)$ 表示，我们对其定义如下，

> Definition 2.1 (泛化误差：Generalization error) 
> 给定一个假设$h\in\mathcal{H}$、一个目标概念$c\in\mathcal{C}$以及一个基础分布$\mathcal{D}$，$h$的泛化误差或风险定义为
$$
R(h)=\underset{x\sim\mathcal{D}}{\operatorname*{\mathbb{P}}}\left[h(x)\neq c(x)\right]=\underset{x\sim\mathcal{D}}{\operatorname*{\mathbb{E}}}\left[1_{h(x)\neq c(x)}\right], \tag{2.1}
$$
其中，$1_{\omega}$ 是事件 $\omega$ 的指示函数。

*注释：
这里我们提到了一个新名词：**事件（Event）**，**事件**是概率和统计中经常提到的一个概念。
在概率论中，**事件** 是一个基本概念，它指的是在某个【实例/样本】空间（Sample Space）中可能发生的一个或一组结果的集合（或者说出现了某种结果性质的情况）。样本空间是所有可能结果的集合，而事件则是对这个空间的子集。事件可以是单个结果，也可以是多个结果的组合，它们满足某些特定的条件或性质。
例如，当我们抛掷一枚硬币时，样本空间是所有可能的结果，即 {正面, 反面}。如果我们定义一个事件为 "正面出现"，那么这个事件就是样本空间的一个子集，包含了结果 "正面"。
由此在概率论中，事件的概念用于定义和计算概率。给定一个事件，我们可以计算它发生的概率。事件的概率是指该事件发生的可能性，通常用0到1之间的数值表示。
在机器学习中，事件的概念更为广泛一些，也被用来描述数据集中的特定模式或类别。例如，在分类任务中，每个类别可以被视为一个事件，算法的目标是学习如何根据输入数据正确地识别这些事件（即类别）。
而在这里来说 **事件 $\omega$** 代指 $h(x)\neq c(x)$，也就是“假设概念$h$和目标概念$c$不等价”这一事件。所以这里也近一步也定义了事件的概率（事件发生的可能性），并将这种可能性定义为泛化误差。*

我们发现，泛化误差是无法直接求得的（其原因在于$\mathcal{D}$的未知性），所以我们需要利用能够知道的信息来近似泛化误差，由此给出经验误差的定义如下，

> Definition 2.2 (Empirical error) 
> 给定假设 $h \in \mathcal{H}$、目标概念 $c \in \mathcal{C}$ 和样本集 $S = \{x_1, ... , x_m\}$，$h$ 的经验误差或经验风险定义为
$$
\widehat{R}_S(h)=\frac{1}{m}\sum_{i=1}^{m}1_{h(x_i)\neq c(x_i)}.\tag{2.2}
$$

可能大家会注意到，在《机器学习理论导引》、《FOML》以及《UML》中，对于泛化误差的定义形式不尽相同。

> 比如在《机器学习理论导引》中泛化误差定义如下：
> 给定样本集 $D={(x_1,y_1),(x_2,y_2),...(x_m,y_m)},x_i \in \mathcal{X},y_i \in \mathcal{Y}=\{-1,+1\}$，而$\mathcal{D}$是 $\mathcal{X}\times\mathcal{Y}$的联合分布，$D \sim \mathcal{D^m}$，且为独立同分布的。
> 令 $h \in \mathcal{H}$ 为 $\mathcal{X}到\mathcal{Y}$的映射，其泛化误差为
$$
E(h;\mathcal{D})={P}_{(x,y)\sim\mathcal{D}}\left(h(x)\neq y\right)= \mathbb{E}_{(x,y)\sim\mathcal{D}} \left[\mathbb{I}({h(x)\neq c(x)})\right], \tag{2.3}
$$

我们要知道，泛化误差公式$(2.1)$和公式$(2.3)$是一致的，只是数学的描述方法不同，公式$(2.3)$是按照$\mathcal{D} \subset \mathcal{X}\times\mathcal{Y}$的联合分布，而公式$(2.1)$是按照$\mathcal{D} \subset \mathcal{X}$的分布，以及一个目标概念$c\in\mathcal{C}$。

在目标概念$c$确定的情况下，$ c(x) = y \in \mathcal{Y}, \forall x \in \mathcal{X} $，所以两者是等价的，经验误差公式同理。

在《钥匙书》**P25** 提到，当样本从样本空间独立同分布采样得到时，经验误差的期望等于其泛化误差。在此，对该证明进行补充。

---
#### 1）【证明补充】经验误差的期望等于其泛化误差

首先需要补充说明「经验误差」和「泛化误差」的概念：

- 泛化误差：泛化误差其实是一个理想化的误差概念。计算泛化误差需要知道样本的真实分布，而在大多数时候，数据样本的真实分布情况并不为人所知。由于人们所获得的信息大多由**采样（sampling）**后的样本提供，因此在这种缺乏真实分布信息情况下，无法求得**泛化误差**。而正是因为泛化误差的不可求，才迫使人们去寻找一种替代的方法来定义学习算法的误差。这一替代品就是**经验误差**。
- 经验误差：经验误差是指学习算法在样本上的误差。当数据与映射关系确定时，便能够求得具体的经验误差。

通过大数定理可以进一步讨论经验误差与泛化误差的关系。当样本量很大时，数据的采样分布接近于真实分布，经验误差的极限也就会趋于泛化误差。另一方面，若将每一个采样的样本都视为随机变量，那么经验误差的期望也就等于泛化误差：

$$
\mathrm{E}[\widehat{R}(h ; D)]=R(h ; \mathcal{D})
$$

证明过程分为两步，首先考察等式右边，泛化误差可表示为： 

$$
R(h ; \mathcal{D})=P_{(x, y) \sim \mathcal{D}}(h(x) \neq y)=\mathbb{E}_{(x, y) \sim \mathcal{D}}[\mathbb{I}(h(x) \neq y)]
$$

然后考察等式左边，经验误差可表示为： 

$$
\widehat{R}(h ; D)=\frac{1}{m} \sum_{i=1}^{m} \mathbb{I}\left(h\left(\boldsymbol{x}_{i}\right) \neq y_{i}\right)
$$

经验误差的期望为： 

$$
\mathrm{E}[\widehat{R}(h ; D)]=\underset{D \sim D^{m}}{\mathrm{E}}[\widehat{R}(h)]=\frac{1}{m} \sum_{i=1}^{m} \underset{(x,y) \sim D}{\mathrm{E}}[\mathbb{I}\left(h\left(\boldsymbol{x}_{i}\right) \neq y_{i}\right)]
$$
 
由于样本是服从独立同分布的，所以所有样本的期望值相同，期望的平均就等于样本的期望，因此：

$$
\mathrm{E}[\widehat{R}(h ; D)]=R(h ; \mathcal{D})
$$

证毕。

---

在《钥匙书》的**P26**提到了可分性的问题，在此对这个概念进行进一步补充说明。

#### 2）【概念补充】假设空间的可分与不可分

- **假设空间** 可分性是一个针对于假设空间的概念，因此需要先理清什么是假设空间。简单来说，假设空间是对于学习算法最大能力的整体刻画。假设空间表述了给定算法所有可能的映射函数。而待学习的概念是样本空间对于标记空间的映射（也就是一个函数映射）。如果目标概念存在于假设空间中，那么对于给定的学习算法，其具备某个映射函数能够正确的区分所有的样本类别。

- **可分性** 可分性（separable）和不可分性（non-separable）是对于假设空间的一种性质的定义。即考察对于给定学习算法，是否存在潜在的、能够完全区分的映射。若存在，则该学习算法对于此假设空间可分；若不存在，则不可分。

   此处的关键在于 **「潜在」** 一词，是一种对于存在性的考察。假设空间中的映射并不惟一，甚至可能是无穷的。例如，在二分类的感知机的案例中，对于 $y=sign(wx+b)$ 而言，任意 $w,b$ 都可以构成一个映射。这些 **「潜在」** 映射就构成了感知机学习算法的假设空间。当人们说该学习算法对于假设空间可分时，意味着对于所有线性可分的样本来说，感知机的假设空间是可区分的。即存在某个 $y=wx+b$ 能够将样本区分开来。

- **严格性与能力上限**

   可分性具有一定的局限性，主要体现在严格性和能力上限的方面。

   可分性的严格性是指，其需要对于所有的样本都可分。有时，由于噪声或者异常值的影响，数据并非完全可区分的，算法只能区分绝大多数的样本。因此可分性没有完全定义学习算法的有效性。

   其次，可分性仅仅表示了学习算法的能力上限。例如，当我们在线性模型中使用高斯核技巧时，能够对任意二分类样本进行区分（维度为无穷）。但从这样一个庞大的假设空间中找到正确对应的映射函数却十分困难。这在深度学习中表现的最为明显。在这个意义上，可分性仅仅表示了学习算法能力上限而已。

## 2.2 PAC学习
在这里给出了经验损失函数和可分性解释后，我们来进一步给出PAC可学习的定义。

**!!!未完待续** 

#### 3.【概念补充】关于$size(c)$

**P27**中的**定义2.2**，**定义2.3**和**定义2.4**通过多项式函数 $poly(1/\epsilon,1/\delta,size(x),size(c))$ 定义了PAC可学、PAC学习算法和样本复杂度等概念。但是对于  $size(c)$ 并没有过多描述，故在此对其进行补充说明。

- **概念的表示**

当谈论一个概念或者概念类的时候，通常使用了一些固有的**「表示方案」**来描述该概念。所谓「表示方案」，即可以通过函数 $\mathcal{R} : \Sigma^* \rightarrow \mathcal{C}$  来实现对概念的表征的方法。其中 $\Sigma$ 是有限符号表（例如{0, 1}），$\Sigma^*$ 是符号组成的合法字符串集合。对于 $\Sigma^*$ 中的任意一个字符串 $\sigma$ ，通过映射 $\mathcal{R}(\sigma) = c$ 产生了概念 c 在 $\mathcal{R}$ 下的一个表示。当然，某概念在 $\mathcal{R}$ 下可能有多种表示。

- **表示的复杂度**

既然概念可以有不同的表示，那么自然也产生了对表示复杂度的讨论。假设与 $\mathcal{R}$ 相关联的映射  $size:\Sigma^* \rightarrow \mathcal{C}$ 可以为每个表示形式分配一个自然数 $size(h)$。  其中， $size(\cdot)$ 是任何符合自然定义的映射关系。例如在 $\Sigma = {0，1}$ 的情形中，我们将 $size(h)$  定义为了 $h$  的二进制长度。当二进制表示不方便时，亦可采用其他的表示方式——但无论如何，新的定义方式始终能够被一个关于二进制长度多项式所描述。例如，我们可以将决策树的大小定义为树中的节点数，无论我们使用什么样的方法对该决策树进行编码，$size(h)$始终可以用一个关于二进制字符串的长度的多项式来进行描述。

- **概念的复杂度**

概念的表示越复杂，越有利于表征概念本身；概念的表示越简单，越不利于表征概念本身。由于在评判目标概念的复杂度时，需要考虑到最差的情况，因此人们往往将目光集中于最简单的概念表示上（此时最不利于了解概念）。由此，定义概念的复杂度 $size(c)$ 为所有表示方案中最简单的表示所对应的复杂度，即：
$$
size(c) = min_{\mathcal{R}(\sigma)=c}{size(\sigma)}
$$



#### 4.【概念补充】时间复杂度

**P27**介绍了时间复杂度和样本复杂度的概念，在此对二者的等价性进行补充。

由于不同的机器、操作系统都会带来完全不一样的运行时间，因此在考察时间复杂度时通常会使用抽象机。抽象机通常是抽象意义上的图灵机或实体意义上的图灵机。在该抽象机中，时间复杂度被定义为了「需要执行的“操作”数量」（关于时间复杂度的严谨表述，见附录）。

一般学习问题是否可以有效解决的问题，取决于如何将其分解为一系列特定的学习问题。考虑学习有限假设类的问题，例如训练示例的数量为  $m_H(\epsilon，δ)= \log(|\mathcal{H}|/δ)/\epsilon^2$ 的数量级的情况。如果，对一个 $h$  评估会花费固定的时间，那么就可以通过对 $\mathcal{H}$ 进行详尽搜索，在时间 $O(|H|m_H(\epsilon，δ))$  内完成这项任务。对于任何固定的有限假设类 $H$，穷举搜索算法都可以在多项式时间内运行。如果问题序列 $|H_n| = n$  ，那么穷举搜索被认为是高效的；如果 $|H_n| = 2 n$ ，则样本复杂度是 $n$ 的多项式，而穷举搜索算法的计算复杂度随 $n$  呈指数增长。此时，穷举搜索被认为是低效的。



#### 5.【概念补充】样本复杂度

**P27**提到了样本复杂度（Sample Complexity）的概念，在此进行补充说明。

- **样本复杂度定义**

**样本复杂度**由这样一个二元函数决定： $\mathcal{m}_{\mathcal{H}}:(0,;1)^2\rightarrow\mathbb{N}$ ，其中，二元函数  $\mathcal{m}$ 的两个自变量分别是要求的精度 (accuracy) $\epsilon$ 和要求的置信度 (confidence)  $\delta$ 。同样， $\mathcal{m}$ 也与假设空间$\mathcal{H}$ 有关系.

每个有限假设类都是PAC可学习且拥有样本复杂度： 
$$
\mathcal{m}_{\mathcal{H}}(\epsilon,\delta)\leq[\frac{\log(|H|/\delta)}{\epsilon}]
$$

- **样本复杂度与数据复杂度$size(c)$区分**

注意，这里的样本复杂度与之前的数据复杂度 $size(c)$  不同，后者指的是一个数据本身的复杂程度，而这里的样本复杂度是关于假设空间$\mathcal{H}$需要样本数量的描述，也即对一个算法，我们需要多少样本才能获得一个 PAC 学习的解（probably approximately correct solution) 。


## 2.3 分析实例
#### 6.【证明补充】布尔合取式

**P30**中提到了布尔合取式的PAC可学问题，在此对该证明进行补充。

布尔合取式（conjunction, 或称合式子）由多个布尔文字（Boolean literals）通过逻辑与运算（AND）连接而成。
相反，析取（disjunction）它由多个布尔文字通过逻辑或运算（OR）连接而成。
一个析取式子（conjunctive clause）可以包含正文字（positive literals）和反文字（negative literals）。
例如，一个合取 $C_1$ 可以是 ${x}_1 \land {x}_2 \land \bar{x}_4$。
对于这样的一个概念来说，所有满足（0，1，？，1）的样本都是正样本，而不满足（0，1，？，1）的样本均为负样本。
当我们拥有足够的样本及其对应的标签时，我们就可以学习到类似 $C_1$ 这样的概念了。

我们用一个更简单的案例来说明如何从样本中学习类似这样的概念。考虑一个新的概念 $C_2 = x_1 \land \bar{x}_3$ ，此时我们有数据

| X1   | X2   | X3   | y    |
| ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 0    |
| 1    | 0    | 0    | 1    |
| 0    | 0    | 1    | 0    |
| 1    | 1    | 0    | 1    |
| +    | ？   | -    |      |

对于所有的 $y=1$，$x_1$都为1，因此在概念$C_2$ 中 $x_1$ 极有可能是 + 的；对于所有的  $y=1$，$x_3$都为0，因此在概念$C_2$ 中 $x_1$ 极有可能是 - 的；对于$x_2$，对应的y可能为0，也可能为1，因此判断  $x_2$ 与概念$C_2$ 无关。
由此，得到  $C_2 = x_1 \land \bar{x}_3$ 。

在PAC可学问题中，我们需要考虑$size(x)$和$size(c)$。
$size(x)$是数据$x$的复杂度是数据的长度，即布尔向量$x$中变量的个数。对于一个有 $n$ 个变量的布尔向量，复杂度 $size(x)$为$n$。
$size(c)$是目标概念 $c$ 的复杂度 $size(c)$ 是合取式中布尔文字（布尔变量及其否定）的个数。
例如，考虑目标概念$c=(x_1 \land \bar{x_2} \land x_3 \land \bar{x_4})$。这个表达式由4个布尔文字组成，因此其复杂度$size(c)$为4。

[Kearns and Vazirani, 1994] 他们所要证明的是 $C_n$ 是PAC可学的，这里我们对证明过程进行补充。
由于 $h$ 的文字总是包含 $c$ 的文字，$h$ 总是至少与 $c$ 一样具体。这意味着：$h$ 包括 $c$ 的所有约束，可能还有更多。
因此，$h$ 在目标概念 $c$ 的负例上永远不会出错。

事实上，要使 $h$ 在负例 $a$ 上出错，必须 $h(a) = 1$（即，$h$ 错误地将 $a$ 分类为正例）。然而，由于 $h$ 包含 $c$ 的所有文字，$h(a) = 1$ 意味着 $c(a) = 1$。
因此，如果 $a$ 是一个负例（即 $c(a) = 0$），则 $h$ 也会评估为 $0$，因为 $h$ 不能在不违反 $c$ 中某个文字的情况下被 $a$ 满足。


#### 7.【案例补充】可知学习

**P31**提到了可知学习与不可知学习，这里用一个案例来进行说明，

在布尔函数中，关于 $d$ 个输入变量有 $2^d$ 种可能。也就是说，当输入的样本量为 $d$ 时，最多有 $2^d$ 种情况。例如，当有2个输入时，一共有4种可能的情况出现，这4种情况对应于16种二元函数假设，如下表所示。

| x1   | x2   | h1   | h2   | h3   | h4   | h5   | h6   | h7   | h8   | h9   | h10  | h11  | h12  | h13  | h14  | h15  | h16  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
| 0    | 1    | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 1    |
| 1    | 0    | 0    | 0    | 1    | 1    | 0    | 0    | 1    | 1    | 0    | 0    | 1    | 1    | 0    | 0    | 1    | 1    |
| 1    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    | 1    |

每个不同的训练实例都会去掉一半的假设。例如，假设我们有 $x_1 = 0 , x_2 = 1$ ，输出为 0 ；这就删除了  $h5、h6、h7、h8、h13、h14、h15、h16$  。这就是学习的一种方式。在布尔函数的情况下，为了得到一个单一的假说，我们需要看到所有的二维训练实例。如果我们得到的训练集只包含所有可能的实例中的一小部分子集——也就是说，如果我们只知道只有一小部分实例的输出应该是什么，那么解就不是唯一的。在看到N个例子之后，还有 $2^{2^d-N}$ 个可能的函数。


例如，如果你有 𝑛 n 个布尔变量 𝑥 1 , 𝑥 2 , … , 𝑥 𝑛 x 1 ​ ,x 2 ​ ,…,x n ​ ，那么一个数据 𝑥 x 可以是这些变量的一个具体取值，例如 ( 1 , 0 , 1 , … , 0 ) (1,0,1,…,0)。


## 部分参考文献

[1] Understanding Machine Learning：3.1，8.1

[2] Foundations of Machine Learning：2

[3] An Introduction to Computational Learning Theory：1.2

------

## 附录：时间复杂度严谨描述

可以分两个步骤定义学习的复杂性。考虑固定学习问题的计算复杂性（由三元组 $(Z, H, \mathcal{l})$ ——学习数据集  (domain set) ，基准假设类 (benchmark hypothesis class)  和 损失函数 确定）。然后，在第二步中，我们考虑一系列此类任务的复杂度变化情况。

1. 给定一个函数$f：(0,1)^2→\mathbb{N}$ ，一个任务 $(Z, H, \mathcal{l})$ 和一个学习 算法 $\mathcal{A}$ ，我们说 $\mathcal{A}$ 能在 $O(f)$ 时间内解决学习任务，如果存在某个常数 c ，对于每个 Z 上的概率分布 D ，算法 $\mathcal{A}$ 基于从分布 D 中独立同分布采样得到的样本，给定的  $\epsilon,;\delta \in (0,1)$ ，能够满足以下条件：
- A最多执行 $cf(\epsilon, \delta)$ 个运算后终止。
- 表示为 $h_A$ 的 $\mathcal{A}$ 的输出在最多使用 $cf(\epsilon, \delta)$ 个示例之后即可用于预测新标签。
- A的输出是 PAC (probably approximately correct) 的，即不超过 $\delta$ 的错误率使结果误差不超过 $\epsilon$。
2. 考虑一系列学习问题， $(Z_n, H_n, \mathcal{l_n})_{n=1}^∞$ ，其中问题 n 由学习数据集 $Z_n$ ，假设类 $H_n$ 和损失函数 $\mathcal{l}*n$ 定义。设 $\mathcal{A}$ 为设计用于解决学习问题的学习算法这种形式。给定一个函数 $g: \mathbb{N} × (0,1)^2 \rightarrow  \mathbb{N}$, 则 $\mathcal{A}$ 的耗时是O(g)。如果对于所有 n ，A求解问题  $(Z_n, H_n, \mathcal{l_n})*{n=1}^∞$ 用时 $O(f_n)$ ，其中$f_n：(0,1)^2\rightarrow\mathbb{N}$ 定义为 $f_n(\sigma，δ)＝ g(n，\sigma，δ)$。